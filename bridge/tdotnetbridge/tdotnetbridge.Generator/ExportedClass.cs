using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace tdotnetbridge.Generator;

public class ExportedClass
{
    public required string Namespace { get; set; }
    public required string Name { get; set; }
    public required IEnumerable<ConstructorDeclarationSyntax> Constructors { get; set; }
    public required IEnumerable<MethodDeclarationSyntax> Methods { get; set; }
    public required IEnumerable<PropertyDeclarationSyntax> Properties { get; set; }
    public string HeaderName => $"{Name.ToLower()}.h";

    private string IncludeGuard =>
        $"DOTNET_MANAGED_GENERATED_CLASS_{$"{Namespace}.{Name}".ToUpper().Replace(".", "_")}";

    public string OutputCode(SemanticModel semanticModel)
    {
        return $$"""
               /// AUTO-GENERATED
               /// This file is autogenerated by tdotnetbridge.Generator
               /// Changes to this file may be overwritten on build!
               
               #ifndef {{IncludeGuard}}
               #define {{IncludeGuard}}
               
               #include <QObject>
               #include <qdotnetobject.h>
               #include <qdotnettask.h>
               #include <qdotnetarray.h>
               
               class {{Name}} : public QObject, public QDotNetObject {
                   Q_OBJECT
               {{
                   string.Join('\n', Properties.Select(syntax => GenerateProperty(syntax, semanticModel)))
               }}
                   
                   public:
                       Q_DOTNET_OBJECT_INLINE({{Name}}, "{{Namespace}}.{{Name}}");
                       
               {{
                   string.Join('\n', Constructors.Select(syntax => GenerateConstructor(syntax, semanticModel)))
               }}
                       
               {{
                   string.Join('\n', Methods.Select(syntax => GenerateMethod(syntax, semanticModel)))
               }}
               
               {{
                   string.Join('\n', Properties.Select(syntax => GeneratePropertyAccessors(syntax, semanticModel)))
               }}
                       
                   private:
               {{
                   string.Join('\n', Methods.Select(syntax => GenerateMethodPrivateMember(syntax, semanticModel)))
               }}
               {{
                   string.Join('\n', Properties.Select(syntax => GeneratePropertyPrivateMember(syntax, semanticModel)))
               }}
               };
               
               #endif // {{IncludeGuard}}
               """;
    }

    private string GeneratePropertyPrivateMember(PropertyDeclarationSyntax property, SemanticModel semanticModel)
    {
        PropertyFlags(property, out var haveGetter, out var haveSetter);

        var name = property.Identifier.ToString();
        
        var typeContext = new TypeContext(semanticModel);
        var type = typeContext.ToCppType(property.Type);
        
        var accessors = new List<string>();

        if (haveGetter)
        {
            accessors.Add($$"""
                                    QDotNetFunction<{{type}}> _fn_property_getter_{{name}};
                            """);
        }

        if (haveSetter)
        {
            accessors.Add($$"""
                                    QDotNetFunction<void, {{type}}> _fn_property_setter_{{name}};
                            """);
        }
        
        return string.Join('\n', accessors);
    }

    private string GeneratePropertyAccessors(PropertyDeclarationSyntax property, SemanticModel semanticModel)
    {
        PropertyFlags(property, out var haveGetter, out var haveSetter);

        var name = property.Identifier.ToString();
        
        var typeContext = new TypeContext(semanticModel);
        var type = typeContext.ToCppType(property.Type);
        
        var accessors = new List<string>();

        if (haveGetter)
        {
            accessors.Add($$"""
                    {{type}} {{Utilities.ToCamelCase(name)}}() {
                        return method("get_{{name}}", _fn_property_getter_{{name}}).invoke(*this);                    
                    }
            """);
        }

        if (haveSetter)
        {
            accessors.Add($$"""
                    void {{Utilities.ToCamelCase($"Set{name}")}}(const {{type}}& {{Utilities.ToCamelCase(name)}}) {
                        return method("set_{{name}}", _fn_property_setter_{{name}}).invoke(*this, {{Utilities.ToCamelCase(name)}});                    
                    }
            """);
        }
        
        return string.Join('\n', accessors);
    }

    private string GenerateProperty(PropertyDeclarationSyntax property, SemanticModel semanticModel)
    {
        PropertyFlags(property, out var haveGetter, out var haveSetter);

        var name = property.Identifier.ToString();
        
        var typeContext = new TypeContext(semanticModel);
        var type = typeContext.ToCppType(property.Type);

        var parts = new List<string>()
        {
            type,
            Utilities.ToCamelCase(name)
        };

        if (haveGetter)
        {
            parts.Add("READ");
            parts.Add(Utilities.ToCamelCase(name));
        }

        if (haveSetter)
        {
            parts.Add("WRITE");
            parts.Add(Utilities.ToCamelCase($"Set{name}"));
        }
        
        return $$"""
            Q_PROPERTY({{string.Join(' ', parts)}})
        """;
    }

    private static void PropertyFlags(PropertyDeclarationSyntax property, out bool haveGetter, out bool haveSetter)
    {
        haveGetter = false;
        haveSetter = false;
        if (property.ExpressionBody is not null)
        {
            // This is a computed property
            haveGetter = true;
            haveSetter = false;
        }
        else if (property.AccessorList is not null)
        {
            var accessors = property.AccessorList.Accessors;
            haveGetter = accessors.Any(a => a.Keyword.Text == "get");
            haveSetter = accessors.Any(a => a.Keyword.Text == "set");
        }
    }

    private string GenerateConstructor(ConstructorDeclarationSyntax constructor, SemanticModel semanticModel)
    {
        var parameters = constructor.ParameterList.Parameters.Select(parameter => (parameter.Type!, parameter.Identifier.ToString())).ToList();
        
        var typeContext = new TypeContext(semanticModel);

        var args = parameters.Select(parameter =>
            $"const {typeContext.ToCppType(parameter.Item1)}& {Utilities.ToCamelCase(parameter.Item2)}");
        var constructorTemplateArgs = parameters.Select(parameter => typeContext.ToCppType(parameter.Item1));
        var invokeArgs = parameters.Select(parameter => Utilities.ToCamelCase(parameter.Item2)).Prepend("nullptr");

        return $$"""
                {{Name}}({{string.Join(", ", args)}}) : QDotNetObject(constructor<{{string.Join(", ", new [] {Name}.Concat(constructorTemplateArgs))}}>().invoke({{string.Join(", ", invokeArgs)}})) {}
        """;
    }

    private string GenerateMethod(MethodDeclarationSyntax method, SemanticModel semanticModel)
    {
        var name = method.Identifier.ToString();
        var returnType = method.ReturnType;
        var parameters = method.ParameterList.Parameters.Select(parameter => (parameter.Type!, parameter.Identifier.ToString())).ToList();

        var typeContext = new TypeContext(semanticModel);

        var args = parameters.Select(parameter =>
            $"const {typeContext.ToCppType(parameter.Item1)}& {Utilities.ToCamelCase(parameter.Item2)}");
        var invokeArgs = parameters.Select(parameter => Utilities.ToCamelCase(parameter.Item2)).Prepend("*this");
        
        return $$"""
                       {{typeContext.ToCppType(returnType)}} {{Utilities.ToCamelCase(name)}}({{string.Join(", ", args)}}) {
                           return method("{{name}}", _fn_{{name}}).invoke({{string.Join(", ", invokeArgs)}});
                       }
               """;
    }

    private string GenerateMethodPrivateMember(MethodDeclarationSyntax method, SemanticModel semanticModel)
    {
        var name = method.Identifier.ToString();
        var parameters = method.ParameterList.Parameters.Select(parameter => parameter.Type);
        var returnType = method.ReturnType;
        
        var typeContext = new TypeContext(semanticModel);

        var templateArgs = parameters.Prepend(returnType).Select(parameter => typeContext.ToCppType(parameter!));
        return $"""
                        QDotNetFunction<{string.Join(", ", templateArgs)}> _fn_{name};
                """;
    }
}
